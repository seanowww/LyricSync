<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>LyricSync – Preview</title>

  <!-- Inter for overlay preview (browser-side) -->
  <link rel="stylesheet"
        href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap">

  <style>
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      margin: 24px;
    }

    .meta { color: #666; font-size: 14px; }

    .controls {
      display: flex;
      gap: 12px;
      align-items: center;
      margin: 12px 0;
      flex-wrap: wrap;
    }

    button { padding: 8px 12px; cursor: pointer; }

    .status { margin-top: 8px; color: #333; }
    .error { color: #b00020; }

    /* Video wrapper controls max width; video itself is 100% width */
    #videoWrap { position: relative; width: min(900px, 100%); margin-top: 12px; }
    #video { width: 100%; display: block; background: #000; }

    #overlay {
      position: absolute;
      left: 0;
      top: 0;
      /* moved via JS to (posX,posY) with transform */
      padding: 0 16px;

      /* MUST be interactive for drag */
      pointer-events: auto;
      cursor: grab;
      user-select: none;

      white-space: pre-wrap;
      text-align: center;
      line-height: 1.15;

      /* Slightly improve perceived smoothness */
      -webkit-font-smoothing: antialiased;
      text-rendering: geometricPrecision;
    }

    #overlay.dragging { cursor: grabbing; }

    .segments { margin-top: 16px; }

    .row {
      display: grid;
      grid-template-columns: 44px 110px 110px 1fr;
      gap: 8px;
      align-items: center;
      margin-bottom: 8px;
    }

    .row input[type="number"] { width: 100%; }
    .row input[type="text"] { width: 100%; }

    .spacer { flex: 1; }
  </style>
</head>

<body>
  <h1>LyricSync – Preview</h1>
  <div class="meta">Edit timing + text, drag the overlay to position it, save to backend, then burn.</div>

  <div class="controls">
    <label>
      Style:
      <select id="style">
        <option value="default">default</option>
        <option value="karaoke">karaoke</option>
        <option value="minimal">minimal</option>
      </select>
    </label>

    <button id="saveBtn">Save</button>
    <button id="burnBtn">Burn MP4</button>

    <span class="spacer"></span>
    <span class="meta" id="debugMeta"></span>
  </div>

  <div id="status" class="status"></div>

  <div id="videoWrap">
    <video id="video" controls></video>
    <div id="overlay"></div>
  </div>

  <h2>Segments</h2>
  <div id="segments" class="segments"></div>

  <script>
    // ============================================================
    // 1) Shared render spec (frontend overlay + backend burn)
    //    Treat these as "VIDEO-PIXEL units" (we scale for display).
    // ============================================================
    const CAL = {
      font: 0.90,
      outline: 1.00,
      margin: 1.00,
    };

    const style = {
      preset: "default",
      fontFamily: "Inter",
      fontSizePx: 28,
      color: "#FFFFFF",
      strokePx: 3,

      // Use HEX for backend sync
      strokeColor: "#000000",

      shadowPx: 0,
      align: "bottom-center",
      maxWidthPct: 90,

      // Single source of truth for position (VIDEO px)
      posX: null,
      posY: null,

      // Frontend-only outline smoothness
      outlineSamples: 16
    };

    // ============================================================
    // 2) DOM refs
    // ============================================================
    const statusEl = document.getElementById("status");
    const segmentsEl = document.getElementById("segments");
    const videoEl = document.getElementById("video");
    const overlayEl = document.getElementById("overlay");
    const debugMetaEl = document.getElementById("debugMeta");

    const saveBtn = document.getElementById("saveBtn");
    const burnBtn = document.getElementById("burnBtn");
    const styleEl = document.getElementById("style");

    // ============================================================
    // 3) State
    // ============================================================
    const params = new URLSearchParams(window.location.search);
    const videoId = params.get("video_id");
    let segments = [];
    let rafId = null;

    let dragging = false;
    let dragStart = null;

    // ============================================================
    // 4) Helpers
    // ============================================================
    function setStatus(msg, isError = false) {
      statusEl.textContent = msg;
      statusEl.className = "status" + (isError ? " error" : "");
    }

    function formatNum(n) {
      if (typeof n !== "number") return n;
      return Math.round(n * 100) / 100;
    }

    function clamp(v, min, max) {
      return Math.max(min, Math.min(max, v));
    }

    function hasOverlap(segs) {
      const s = [...segs].sort((a,b) => Number(a.start) - Number(b.start));
      for (let i = 1; i < s.length; i++) {
        if (Number(s[i].start) < Number(s[i-1].end)) return true;
      }
      return false;
    }

    function getActiveCaption(t) {
      for (const seg of segments) {
        const start = Number(seg.start);
        const end = Number(seg.end);
        if (t >= start && t < end) return seg.text ?? "";
      }
      return "";
    }

    function hexToRgba(hex, alpha = 0.85) {
      const c = (hex || "#000000").replace("#", "");
      if (c.length !== 6) return `rgba(0,0,0,${alpha})`;
      const r = parseInt(c.slice(0, 2), 16);
      const g = parseInt(c.slice(2, 4), 16);
      const b = parseInt(c.slice(4, 6), 16);
      return `rgba(${r},${g},${b},${alpha})`;
    }

    // ============================================================
    // 5) Overlay styling
    // ============================================================
    function buildSmoothOutlineShadows(radiusPx, color, samples = 16) {
      const out = [];
      for (let i = 0; i < samples; i++) {
        const angle = (i / samples) * Math.PI * 2;
        const dx = Math.cos(angle) * radiusPx;
        const dy = Math.sin(angle) * radiusPx;
        out.push(`${dx.toFixed(2)}px ${dy.toFixed(2)}px 0 ${color}`);
      }
      return out.join(", ");
    }

    function ensureDefaultPosition() {
      const vw = videoEl.videoWidth;
      const vh = videoEl.videoHeight;
      if (!vw || !vh) return;

      // Default: bottom-center-ish
      const defaultX = vw / 2;
      const defaultY = vh * 0.88;

      if (style.posX == null) style.posX = defaultX;
      if (style.posY == null) style.posY = defaultY;
    }

    function applyOutline(scaleX) {
      const strokeDisplayPx = Math.max(1, Math.round(style.strokePx * scaleX));
      const outlineColor = hexToRgba(style.strokeColor, 0.90);

      // For consistency, avoid webkitTextStroke; use text-shadow ring
      overlayEl.style.webkitTextStroke = "0px transparent";
      overlayEl.style.textShadow = buildSmoothOutlineShadows(
        strokeDisplayPx,
        outlineColor,
        style.outlineSamples
      );
    }

    function applyOverlayStyle() {
      if (!videoEl.videoWidth || !videoEl.videoHeight) return;

      ensureDefaultPosition();

      const rect = videoEl.getBoundingClientRect();
      const scaleX = rect.width / videoEl.videoWidth;
      const scaleY = rect.height / videoEl.videoHeight;

      overlayEl.style.fontFamily = `${style.fontFamily}, system-ui, sans-serif`;
      overlayEl.style.color = style.color;

      // VIDEO px -> display px
      overlayEl.style.fontSize = (style.fontSizePx * scaleX) + "px";

      // Anchor bottom-center at (posX,posY):
      // left/top are the anchor point; transform moves element so that its bottom-center sits at that point.
      overlayEl.style.left = (style.posX * scaleX) + "px";
      overlayEl.style.top  = (style.posY * scaleY) + "px";
      overlayEl.style.transform = "translate(-50%, -100%)";

      overlayEl.style.textAlign = "center";
      overlayEl.style.width = style.maxWidthPct + "%";
      overlayEl.style.maxWidth = style.maxWidthPct + "%";
      overlayEl.style.margin = "0 auto";

      applyOutline(scaleX);

      // debug
      debugMetaEl.textContent =
        `pos=(${style.posX.toFixed(0)},${style.posY.toFixed(0)})  video=${videoEl.videoWidth}×${videoEl.videoHeight}`;
    }

    function applyPreset(preset) {
      style.preset = preset;

      // Only modify properties that exist now (NO marginBottomPx)
      if (preset === "minimal") {
        style.fontSizePx = 28;
        style.strokePx = 3;
        style.shadowPx = 0;
      } else if (preset === "karaoke") {
        style.fontSizePx = 32;
        style.strokePx = 4;
        style.shadowPx = 0;
      } else {
        style.fontSizePx = 28;
        style.strokePx = 3;
        style.shadowPx = 0;
      }

      // Keep existing posX/posY; do not reset position when switching style
    }

    // ============================================================
    // 6) Dragging (updates style.posX / style.posY in VIDEO px)
    // ============================================================
    function startDrag(e) {
      if (!videoEl.videoWidth || !videoEl.videoHeight) return;

      dragging = true;
      overlayEl.classList.add("dragging");

      const rect = videoEl.getBoundingClientRect();

      dragStart = {
        mouseX: e.clientX,
        mouseY: e.clientY,
        startPosX: style.posX,
        startPosY: style.posY,
        rect,
      };

      // Prevent text selection while dragging
      e.preventDefault();
    }

    function onDragMove(e) {
      if (!dragging || !dragStart) return;

      const rect = dragStart.rect;
      const scaleX = rect.width / videoEl.videoWidth;
      const scaleY = rect.height / videoEl.videoHeight;

      const dxDisp = e.clientX - dragStart.mouseX;
      const dyDisp = e.clientY - dragStart.mouseY;

      const dxVid = dxDisp / scaleX;
      const dyVid = dyDisp / scaleY;

      let nx = dragStart.startPosX + dxVid;
      let ny = dragStart.startPosY + dyVid;

      // Clamp within video frame (anchor point must stay inside)
      nx = clamp(nx, 0, videoEl.videoWidth);
      ny = clamp(ny, 0, videoEl.videoHeight);

      style.posX = nx;
      style.posY = ny;

      applyOverlayStyle();
    }

    function endDrag() {
      if (!dragging) return;
      dragging = false;
      dragStart = null;
      overlayEl.classList.remove("dragging");
    }

    // Mouse drag
    overlayEl.addEventListener("mousedown", startDrag);
    window.addEventListener("mousemove", onDragMove);
    window.addEventListener("mouseup", endDrag);

    // Touch drag (minimal support)
    overlayEl.addEventListener("touchstart", (e) => {
      const t = e.touches[0];
      startDrag({ clientX: t.clientX, clientY: t.clientY, preventDefault: () => e.preventDefault() });
    }, { passive: false });

    window.addEventListener("touchmove", (e) => {
      if (!dragging) return;
      const t = e.touches[0];
      onDragMove({ clientX: t.clientX, clientY: t.clientY });
    }, { passive: true });

    window.addEventListener("touchend", endDrag);

    // ============================================================
    // 7) Segments UI
    // ============================================================
    function renderSegments() {
      segmentsEl.innerHTML = "";

      segments.forEach((seg, idx) => {
        const row = document.createElement("div");
        row.className = "row";

        const playBtn = document.createElement("button");
        playBtn.textContent = "▶";
        playBtn.title = "Jump to segment";
        playBtn.addEventListener("click", () => {
          const t = Number(seg.start) || 0;
          videoEl.currentTime = Math.max(0, t);
          videoEl.play().catch(() => {});
        });

        const startInput = document.createElement("input");
        startInput.type = "number";
        startInput.step = "0.01";
        startInput.value = formatNum(Number(seg.start) || 0);
        startInput.addEventListener("input", (e) => {
          segments[idx].start = Number(e.target.value);
        });

        const endInput = document.createElement("input");
        endInput.type = "number";
        endInput.step = "0.01";
        endInput.value = formatNum(Number(seg.end) || 0);
        endInput.addEventListener("input", (e) => {
          segments[idx].end = Number(e.target.value);
        });

        const textInput = document.createElement("input");
        textInput.type = "text";
        textInput.value = seg.text ?? "";
        textInput.addEventListener("input", (e) => {
          segments[idx].text = e.target.value;
        });

        row.appendChild(playBtn);
        row.appendChild(startInput);
        row.appendChild(endInput);
        row.appendChild(textInput);
        segmentsEl.appendChild(row);
      });
    }

    // ============================================================
    // 8) API calls
    // ============================================================
    async function loadInitialData() {
      if (!videoId) {
        setStatus("Missing video_id in URL. Go back and upload again.", true);
        saveBtn.disabled = true;
        burnBtn.disabled = true;
        return;
      }

      videoEl.src = `/api/video/${encodeURIComponent(videoId)}`;

      setStatus("Loading segments...");
      try {
        const res = await fetch(`/api/segments/${encodeURIComponent(videoId)}`);
        if (!res.ok) {
          const msg = await res.text().catch(() => res.statusText);
          setStatus(`Failed to load segments (${res.status}): ${msg}`, true);
          return;
        }
        const data = await res.json();
        segments = data.segments || [];
        renderSegments();
        setStatus(`Loaded ${segments.length} segments.`);
      } catch (err) {
        setStatus("Request failed: " + err.message, true);
      }
    }

    async function saveSegments() {
      setStatus("Saving...");
      saveBtn.disabled = true;

      if (hasOverlap(segments)) {
        setStatus("Save failed: overlapping segments not supported yet. Adjust timings so they don't overlap.", true);
        saveBtn.disabled = false;
        return false;
      }

      try {
        const res = await fetch(`/api/segments/${encodeURIComponent(videoId)}`, {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ segments })
        });

        if (!res.ok) {
          const msg = await res.text().catch(() => res.statusText);
          setStatus(`Save failed (${res.status}): ${msg}`, true);
          return false;
        }

        setStatus("Saved ✅");
        return true;
      } catch (err) {
        setStatus("Save request failed: " + err.message, true);
        return false;
      } finally {
        saveBtn.disabled = false;
      }
    }

    function downloadBlob(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    async function burnVideo() {
      const ok = await saveSegments();
      if (!ok) return;

      setStatus("Burning subtitles (this may take a bit)...");
      burnBtn.disabled = true;

      try {
        const payload = {
          video_id: videoId,
          segments,
          style
        };

        const res = await fetch("/api/burn", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });

        if (!res.ok) {
          const msg = await res.text().catch(() => res.statusText);
          setStatus(`Burn failed (${res.status}): ${msg}`, true);
          return;
        }

        const blob = await res.blob();
        downloadBlob(blob, `lyricsync_${videoId}.mp4`);
        setStatus("Burn complete ✅ Download started.");
      } catch (err) {
        setStatus("Burn request failed: " + err.message, true);
      } finally {
        burnBtn.disabled = false;
      }
    }

    // ============================================================
    // 9) Overlay update loop (smooth + consistent)
    // ============================================================
    function startOverlayLoop() {
      if (rafId) cancelAnimationFrame(rafId);

      const tick = () => {
        overlayEl.textContent = getActiveCaption(videoEl.currentTime);
        rafId = requestAnimationFrame(tick);
      };

      rafId = requestAnimationFrame(tick);
    }

    // ============================================================
    // 10) Events
    // ============================================================
    saveBtn.addEventListener("click", saveSegments);
    burnBtn.addEventListener("click", burnVideo);

    styleEl.addEventListener("change", () => {
      applyPreset(styleEl.value);
      applyOverlayStyle();
    });

    videoEl.addEventListener("loadedmetadata", () => {
      ensureDefaultPosition();
      applyOverlayStyle();
      requestAnimationFrame(applyOverlayStyle);
      startOverlayLoop();
    });

    window.addEventListener("resize", () => {
      applyOverlayStyle();
      requestAnimationFrame(applyOverlayStyle);
    });

    // Init
    applyPreset(styleEl.value);
    loadInitialData();
  </script>
</body>
</html>
